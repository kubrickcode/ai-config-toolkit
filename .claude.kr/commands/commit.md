---
allowed-tools: Bash(git status:*), Bash(git diff:*), Bash(git log:*), Bash(git branch:*), Read, Grep, Write
description: Conventional Commits 규격(feat/fix/docs/chore)에 따라 한국어와 영어 커밋 메시지 생성
---

# Conventional Commits 메시지 생성기

[Conventional Commits v1.0.0](https://www.conventionalcommits.org/) 규격을 따르는 커밋 메시지를 한국어와 영어로 생성합니다. **하나를 선택하여 커밋에 사용하세요.**

## 저장소 상태 분석

- Git 상태: !git status --porcelain
- 현재 브랜치: !git branch --show-current
- 스테이징된 변경사항: !git diff --cached --stat
- 스테이징되지 않은 변경사항: !git diff --stat
- 최근 커밋: !git log --oneline -10

## 이 명령의 기능

1. 현재 브랜치명을 확인하여 이슈 번호 감지 (예: develop/shlee/32 → #32)
2. git status로 스테이징된 파일 확인
3. git diff를 수행하여 커밋될 변경사항 파악
4. 한국어와 영어로 Conventional Commits 형식의 커밋 메시지 생성
5. 브랜치명이 숫자로 끝나면 "fix #N" 추가
6. **commit_message.md 파일로 저장하여 복사하기 편리하게 제공**

## Conventional Commits 형식 (필수)

```
<type>[(optional scope)]: <description>

[optional body]

[optional footer: fix #N]
```

### 사용 가능한 타입

스테이징된 변경사항을 분석하여 가장 적절한 타입을 제안:

| 타입         | 사용 시점                                   | SemVer 영향   |
| ------------ | ------------------------------------------- | ------------- |
| **feat**     | 새로운 기능이나 역량 추가                   | MINOR (0.x.0) |
| **fix**      | 사용자가 겪는 버그 수정                     | PATCH (0.0.x) |
| **ifix**     | 인프라/내부 버그 수정 (CI, 빌드, 배포)      | PATCH (0.0.x) |
| **perf**     | 성능 개선                                   | PATCH         |
| **docs**     | 문서만 변경 (README, 주석 등)               | PATCH         |
| **style**    | 코드 포매팅, 세미콜론 누락 (로직 변경 없음) | PATCH         |
| **refactor** | 동작 변경 없는 코드 구조 개선               | PATCH         |
| **test**     | 테스트 추가 또는 수정                       | PATCH         |
| **chore**    | 빌드 설정, 의존성, 도구 업데이트            | PATCH         |
| **ci**       | CI/CD 설정 변경                             | PATCH         |

**BREAKING CHANGE**: 반드시 type! 형식(타입 뒤에 느낌표)과 BREAKING CHANGE: footer에 마이그레이션 가이드를 함께 포함해야 함 (major 버전 증가).

예시:

```
feat!: API 응답 형식을 JSON에서 MessagePack으로 변경

MessagePack 바이너리 형식 도입으로 패킷 크기 40% 감소.

BREAKING CHANGE: 클라이언트 코드 수정 필요
- MessagePack 라이브러리 설치: npm install msgpack5
- 응답 파싱 변경: response.json() → msgpack.decode(response.body)
- 타입 정의 업데이트: API_RESPONSE_FORMAT 상수 변경
```

### 타입 선택 결정 트리

git diff 출력을 분석하여 파일 패턴 기반으로 타입 제안:

```
변경된 파일 → 제안 타입

src/**/*.{ts,js,tsx,jsx} + 새 함수/클래스 → feat
src/**/*.{ts,js,tsx,jsx} + 버그 수정 → fix
README.md, docs/**, *.md → docs
package.json, pnpm-lock.yaml, .github/** → chore
**/*.test.{ts,js}, **/*.spec.{ts,js} → test
.github/workflows/** → ci
```

여러 타입이 해당되면 우선순위: `feat` > `fix` > 기타 타입.

### 헷갈리는 케이스: fix vs ifix vs chore 구분

**핵심 기준**: **사용자**에게 영향을 주는가, **개발자/인프라**에만 영향을 주는가?

| 상황                                                    | 타입       | 이유                                        |
| ------------------------------------------------------- | ---------- | ------------------------------------------- |
| 백엔드 GitHub Actions 테스트 워크플로우가 동작하지 않음 | `ifix`     | 개발을 막는 CI/CD 버그                      |
| OOM 에러로 배포 실패                                    | `ifix`     | 릴리스를 막는 인프라 버그                   |
| E2E 테스트가 불안정하여 오탐 발생                       | `ifix`     | 테스트 인프라 버그                          |
| Vite 프로덕션 빌드 시 타임아웃 발생                     | `ifix`     | 빌드 시스템 버그                            |
| API가 정상 요청에 500 에러 반환                         | `fix`      | 사용자가 에러 응답을 경험함                 |
| 페이지 로딩 속도가 3초에서 0.8초로 개선                 | `perf`     | 사용자가 직접 체감하는 개선                 |
| 프로필 페이지 접근 시 앱 종료                           | `fix`      | 사용자가 크래시를 경험함                    |
| 내부 데이터베이스 쿼리 최적화 (사용자 무체감)           | `refactor` | 코드 개선, 사용자에게 측정 가능한 이점 없음 |
| 의존성 보안 패치 (CVE 수정)                             | `chore`    | 빌드/도구 업데이트 (버그 수정 아님)         |
| 새로운 기능을 위한 React 버전 업그레이드                | `chore`    | 의존성 업데이트 (버그 수정 아님)            |

**판단 플로우차트:**

```
버그(고장난 것)인가?
├─ 아니오 → chore/refactor/docs 등 사용
└─ 예 → 최종 사용자에게 영향을 주는가?
    ├─ 예 → fix (사용자 대면 버그)
    └─ 아니오 → ifix (인프라/개발자 버그)
```

**예시:**

- ✅ `fix: 로그인 버튼이 반응하지 않는 문제 수정` (사용자 문제)
- ✅ `ifix: Docker 빌드 시 환경변수 누락으로 실패하는 문제 수정` (인프라 버그)
- ✅ `ifix: Prisma 마이그레이션 스크립트 문법 오류 수정` (개발자 도구 버그)
- ❌ ~~`fix: ItemService의 null pointer exception 수정`~~ → `fix: 항목 조회 시 앱이 종료되는 문제 수정` 사용 (사용자 관점)

## 커밋 메시지 작성 가이드라인

**핵심 원칙: 근본 원인 → 선택 근거 → 구현 방법**

커밋 메시지는 의사결정의 **역사**를 기록합니다. 단순한 코드 변경 목록이 아닙니다. 모든 비자명한 커밋 본문은 반드시 다음을 포함해야 합니다:

1. **WHY-Problem**: 왜 이 문제가 발생했는가? (증상이 아닌 근본 원인)
2. **WHY-Solution**: 왜 이 해결책인가? (의사결정 근거, 검토한 대안들)
3. **HOW**: 어떻게 해결했는가? (구현 요약)

이것은 미래 유지보수자를 위한 **역사적 문서화**이며, 변경 로그 항목이 아닙니다.

**제목 작성 원칙: 사용자 관점에서 겪는 문제를 우선적으로 표현**

- ❌ "빈 로그인 폼 제출 오류 수정" (코드 관점)
- ✅ "로그인 버튼 클릭 시 반응 없는 문제 수정" (사용자 관점)
- ❌ "null 포인터 예외 처리" (기술적 관점)
- ✅ "프로필 페이지 접근 시 앱 종료되는 문제 수정" (사용자 관점)

### 피해야 할 안티패턴

❌ **변경사항 나열 (diff를 글로 다시 쓰는 것)**:

```
fix: 성능 개선

- 데이터베이스 인덱스 추가
- 캐싱 구현
- 쿼리 최적화
```

✅ **근본 원인 + 선택 근거**:

```
fix: 결제 페이지 부하 시 타임아웃

결제/재고/배송 API를 순차 호출하여 단일 서비스가 3초를 초과하면 연쇄 타임아웃 발생.

Promise.all()로 병렬 처리 전환하여 최악의 경우 9초에서 3초로 단축.
실시간 재고 정확성 요구로 큐 기반 접근 제외.
```

❌ **증상만 기술**:

```
fix: 프로필 페이지에서 에러 발생

null 참조 에러로 프로필 페이지 크래시.
null 체크 추가로 해결.
```

✅ **근본 원인 분석**:

```
fix: 프로필 페이지에서 에러 발생

S3 객체 미존재 시 Profile API가 avatar_url을 null로 반환하지만, 프론트엔드는 구버전 API 문서 기반으로 non-null을 가정.

모바일 앱 v1.x와의 하위 호환성 유지를 위해 API 수정 대신 기본 아바타로 null coalescing 적용.
```

❌ **컨텍스트 없는 구현 세부사항**:

```
refactor: Redux Toolkit으로 마이그레이션

모든 Redux 보일러플레이트를 Redux Toolkit으로 교체.
코드 40% 감소.
```

✅ **의사결정 근거**:

```
refactor: Redux Toolkit으로 마이그레이션

수동 Redux 패턴은 기능당 5개 파일(actions, types, reducer, selectors, middleware)이 필요하여 새 기능 개발에 상태 스캐폴딩만 2일 이상 소요.

Redux DevTools 호환성을 유지하면서 보일러플레이트 감소를 위해 Redux Toolkit 채택.
기존 200+ 컴포넌트가 Redux 패턴에 깊이 결합되어 있어 Zustand/Jotai 제외.
```

### 복잡도 기반 형식

간단하고 간결하게 작성. 복잡도에 따라 적절한 형식 사용:

#### 매우 간단한 변경사항 (WHY 불필요)

근본 원인이 자명한 사소한 변경에만 사용:

```
type: 간결한 설명
```

**예시:**

```
docs: README 오타 수정
```

#### 간단한 변경사항 (최소한의 WHY)

근본 원인은 단순하지만 해결책 선택이 중요한 경우:

```
type: 문제 상황 설명

근본 원인 한 문장.
이 해결책을 선택한 이유 (자명하지 않은 경우).
```

**예시:**

```
fix: 빈 필드로 로그인 버튼 무반응

빈 폼 검증 Promise가 에러 경로에서 reject되지 않아 UI가 해결을 기다리며 멈춤.

검증 체인에 명시적 에러 처리 추가.
```

**여러 변경사항/이유가 있을 때는 리스트 형식 사용:**

```
refactor: 백엔드 아키텍트 에이전트 역할 재정의

- API 설계 중심에서 시스템 구조 설계 중심으로 역할 변경
- 도메인 모델링, 계층 아키텍처, 모듈화 전략에 집중하도록 수정
```

#### 표준 변경사항

```
type: 문제 상황 설명

발생한 문제 상황 설명
(재현 가능하면 간단한 재현 방법)

근본 원인 설명과 이 해결 방법을 선택한 이유

fix #N
```

**예시:**

```
fix: 사용자 목록 페이지 로딩 실패

1000명 이상일 때 사용자 목록 페이지가 계속 로딩 스피너만 표시
(재현: 사용자 목록 > 전체 보기 클릭)

user_created_at 컬럼에 인덱스가 없어 1000+ 레코드 정렬 시 30초 이상의 full table scan 발생.

8개 기존 UI 화면이 클라이언트 측 필터링을 위해 전체 데이터셋에 의존하여 pagination 대신 composite index + Redis 캐싱 선택.
pagination은 모든 화면의 프론트엔드 수정 필요.

fix #32
```

#### 복잡한 변경사항 (드물게 필요)

```
type: 문제 상황 설명

문제:
- 구체적인 문제 상황 설명
- 근본 원인 분석

해결책:
- 대안 대비 이 방법을 선택한 이유
- 의사결정에 영향을 준 트레이드오프와 제약사항

fix #N
```

**예시:**

```
fix: 서비스 업데이트 시 자동 로그아웃

문제:
- 새 버전 배포할 때마다 모든 사용자가 강제 로그아웃
- 롤링 업데이트 중 pod 재시작 시 메모리 내 세션 스토리지 손실
- K8s 인스턴스 간 세션 유지 메커니즘 부재

해결책:
- 현재 인프라에서 로드밸런서가 세션 어피니티를 지원하지 않아 sticky sessions 대신 Redis 선택
- 자동 재인증을 위한 JWT 리프레시 토큰 추가
- 200ms 지연 vs 5ms Redis로 인해 데이터베이스 세션 스토리지 제외

fix #48
```

**중요한 형식 규칙:**

- 첫 줄(제목): `type: 사용자가 경험하는 문제를 명확히 표현`
- description은 소문자로 시작, 마침표 없음, 명령형 사용
- 가능한 한 사용자 관점 > 코드/기술 관점으로 작성
- 아주 간단한 케이스 제외하고 단순히 변경사항 나열 금지 - 문장으로 설명
- 해결 방법 설명 시 근본 원인과 의사결정 근거 포함
- 설명은 간결하게 - 코드에서 명백한 내용은 장황하게 설명하지 않음
- 브랜치명이 숫자로 끝나면 (예: develop/32, develop/shlee/45) 끝에 "fix #N" 추가
- **여러 변경사항/이유가 있을 때는 불릿 포인트(-)를 사용하여 가독성 향상**
- **문장 중간에서 임의로 줄바꿈 금지** - 한 문장은 한 줄에 작성. 줄바꿈은 문장이 끝난 후에만

### "왜 이 해결책인가" 표현하기

좋은 근거는 대안과 트레이드오프를 언급합니다:

**의사결정 프레임워크:**

1. 어떤 다른 해결책을 검토했는가?
2. 왜 그것들을 제외했는가?
3. 어떤 제약사항이 최종 선택을 이끌었는가?

**예시:**

- ❌ 약함: "캐싱에 Redis 사용"
- ✅ 강함: "여러 API 인스턴스가 공유 캐시 상태를 필요로 하여 인메모리 캐시 대신 Redis 선택"

- ❌ 약함: "composition으로 리팩토링"
- ✅ 강함: "기능 추가 시 7개 부모 클래스 수정이 필요하여 상속에서 composition으로 전환"

- ❌ 약함: "검증 추가로 해결"
- ✅ 강함: "사용자 친화적 에러 메시지 반환을 위해 데이터베이스 제약조건 대신 API 레이어에서 입력 검증"

**일반적인 트레이드오프 범주:**

- 성능 vs 유지보수성
- 하위 호환성 vs 깔끔한 설계
- 빠른 수정 vs 구조적 리팩토링
- 클라이언트 측 vs 서버 측 해결
- 라이브러리 의존성 vs 커스텀 구현

## 출력 형식

명령이 제공하는 내용:

1. 스테이징된 변경사항 분석 (없으면 모든 변경사항)
2. **commit_message.md 파일 생성** - 한국어와 영어 버전 모두 포함
3. 파일에서 원하는 버전을 복사하여 사용

## 중요 사항

- 이 명령은 커밋 메시지만 생성하며 - 실제 커밋은 수행하지 않음
- **commit_message.md 파일에 두 버전 모두 저장** - 원하는 것 선택
- **근본 원인과 선택 근거에 집중** - 단순 변경사항 나열 금지
- 해결 방법 설명 시 **왜 대안 대신 이 접근법을 선택했는지** 설명
- 메시지는 간결하게 - 코드에서 명백한 내용은 과도하게 설명하지 않음
- 브랜치 이슈 번호(예: develop/32)는 자동으로 "fix #N" 추가
- 생성된 파일에서 메시지 복사 후 `git commit`을 수동으로 실행
- **스펙 준수**: 모든 메시지는 Conventional Commits 형식 필수
- **타입 필수**: 타입 없음 = semantic-release에서 무효 커밋
- **대소문자 구분**: 타입은 소문자 (`BREAKING CHANGE` 제외)

## Claude 실행 지침

### Phase 1: WHY 발견 (diff 분석 전)

1. 현재 대화에서 문제/해결책 논의 확인
2. 브랜치명, 파일명, 테스트 설명에서 컨텍스트 추출
3. 변경된 파일을 읽어 의도를 나타내는 주석, 함수명, 테스트 설명 확인
4. 컨텍스트가 불충분하고 변경이 비자명하면, 코드가 해결하려는 문제 추론

### Phase 2: WHAT 분석 (git 분석)

5. git 명령어를 실행하여 스테이징된 변경사항 확인 (없으면 전체)
6. 파일 패턴 분석하여 적절한 커밋 타입 제안
7. Phase 1의 문제 컨텍스트와 변경사항 매칭

### Phase 3: 메시지 생성

8. scope 필요 여부 판단 (예: `fix(api):`, `feat(ui):`)
9. 커밋 메시지 작성:
   - 제목: `<type>[(scope)]: <사용자 관점 설명>`
   - 본문: 필수 3단계 분석 ("매우 간단" 제외)
     a) 근본 원인 식별: 어떤 근본적 문제가 이것을 야기했는가?
     b) 해결책 선택 이유 설명: 왜 대안 대신 이 접근법인가?
     c) 구현 요약: 어떻게 해결했는가?
   - Footer: 브랜치명이 숫자로 끝나면 `fix #N` 자동 추가
10. 변경 범위에 따라 형식 복잡도 선택 (매우 간단/간단/표준/복잡)

### Phase 4: 자가 검증

11. 자가 점검: "이 메시지가 git diff에서 알 수 없는 정보를 담고 있는가?"
12. 아니라면 근본 원인이나 의사결정 근거 추가로 수정
13. 6개월 후 개발자가 WHY를 이해할 수 있는 메시지인지 확인

### 출력

14. 한국어와 영어 버전 모두 생성
15. `/workspaces/ai-config-toolkit/commit_message.md`에 저장
16. 제안 타입과 근거 제시

**컨텍스트 인식 분석**: 토큰 비용과 메시지 품질 균형:

- `git log --oneline -5`로 커밋 스타일 일관성 확인
- 유의미한 변경이 있는 파일만 읽기 (사소한 공백 변경 제외)
- 변경된 파일에 테스트가 있으면 테스트 설명에서 의도 신호 확인
- 변경 근처의 TODO/FIXME 주석에서 의도 설명 찾기
- WHY를 이해하는 데 토큰 투자 - 품질 있는 커밋 메시지가 빠른 것보다 낫다
