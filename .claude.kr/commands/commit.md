---
allowed-tools: Bash(git status:*), Bash(git diff:*), Bash(git log:*), Bash(git branch:*), Write
description: Conventional Commits 규격(feat/fix/docs/chore)에 따라 한국어와 영어 커밋 메시지 생성
---

# Conventional Commits 메시지 생성기

[Conventional Commits v1.0.0](https://www.conventionalcommits.org/) 규격을 따르는 커밋 메시지를 한국어와 영어로 생성합니다. **하나를 선택하여 커밋에 사용하세요.**

## 저장소 상태 분석

- Git 상태: !git status --porcelain
- 현재 브랜치: !git branch --show-current
- 스테이징된 변경사항: !git diff --cached --stat
- 스테이징되지 않은 변경사항: !git diff --stat
- 최근 커밋: !git log --oneline -10

## 이 명령의 기능

1. 현재 브랜치명을 확인하여 이슈 번호 감지 (예: develop/shlee/32 → #32)
2. git status로 스테이징된 파일 확인
3. git diff를 수행하여 커밋될 변경사항 파악
4. 한국어와 영어로 Conventional Commits 형식의 커밋 메시지 생성
5. 브랜치명이 숫자로 끝나면 "fix #N" 추가
6. **commit_message.md 파일로 저장하여 복사하기 편리하게 제공**

## Conventional Commits 형식 (필수)

```
<type>[(optional scope)]: <description>

[optional body]

[optional footer: fix #N]
```

### 사용 가능한 타입

스테이징된 변경사항을 분석하여 가장 적절한 타입을 제안:

| 타입 | 사용 시점 | SemVer 영향 |
|------|----------|------------|
| **feat** | 새로운 기능이나 역량 추가 | MINOR (0.x.0) |
| **fix** | 버그 수정 또는 문제 해결 | PATCH (0.0.x) |
| **docs** | 문서만 변경 (README, 주석 등) | 없음 |
| **style** | 코드 포매팅, 세미콜론 누락 (로직 변경 없음) | 없음 |
| **refactor** | 동작 변경 없는 코드 구조 개선 | 없음 |
| **perf** | 성능 개선 | PATCH |
| **test** | 테스트 추가 또는 수정 | 없음 |
| **chore** | 빌드 설정, 의존성, 도구 업데이트 | 없음 |
| **ci** | CI/CD 설정 변경 | 없음 |

**BREAKING CHANGE**: 반드시 type! 형식(타입 뒤에 느낌표)과 BREAKING CHANGE: footer에 마이그레이션 가이드를 함께 포함해야 함 (major 버전 증가).

예시:
```
feat!: API 응답 형식을 JSON에서 MessagePack으로 변경

MessagePack 바이너리 형식 도입으로 패킷 크기 40% 감소.

BREAKING CHANGE: 클라이언트 코드 수정 필요
- MessagePack 라이브러리 설치: npm install msgpack5
- 응답 파싱 변경: response.json() → msgpack.decode(response.body)
- 타입 정의 업데이트: API_RESPONSE_FORMAT 상수 변경
```

### 타입 선택 결정 트리

git diff 출력을 분석하여 파일 패턴 기반으로 타입 제안:

```
변경된 파일 → 제안 타입

src/**/*.{ts,js,tsx,jsx} + 새 함수/클래스 → feat
src/**/*.{ts,js,tsx,jsx} + 버그 수정 → fix
README.md, docs/**, *.md → docs
package.json, pnpm-lock.yaml, .github/** → chore
**/*.test.{ts,js}, **/*.spec.{ts,js} → test
.github/workflows/** → ci
```

여러 타입이 해당되면 우선순위: `feat` > `fix` > 기타 타입.

### 헷갈리는 케이스: fix vs chore 구분

**핵심 기준**: **사용자**에게 영향을 주는가, **개발자**에게만 영향을 주는가?

| 상황 | 타입 | 이유 |
|------|------|------|
| 백엔드 GitHub Actions 테스트 워크플로우가 동작하지 않음 | `chore` | CI/CD에만 영향, 사용자는 이를 경험하지 않음 |
| API가 정상 요청에 500 에러 반환 | `fix` | 사용자가 에러 응답을 경험함 |
| 페이지 로딩 속도가 3초에서 0.8초로 개선 | `perf` | 사용자가 직접 체감하는 개선 |
| 내부 데이터베이스 쿼리 최적화 (사용자 무체감) | `refactor` | 코드 개선, 사용자에게 측정 가능한 이점 없음 |
| 의존성 보안 패치 (CVE 수정) | `chore` | 빌드/도구 업데이트 |
| 프로필 페이지 접근 시 앱 종료 | `fix` | 사용자가 크래시를 경험함 |

**사용자 관점 우선:**
- ✅ "fix: 항목 삭제 시 앱이 종료되는 문제 수정" (사용자 문제)
- ❌ "fix: ItemService의 null pointer exception 수정" (코드 문제)

## 커밋 메시지 작성 가이드라인

**핵심 원칙: 무엇을 했는지보다 무슨 문제를 해결했는지에 집중**

**제목 작성 원칙: 사용자 관점에서 겪는 문제를 우선적으로 표현**

- ❌ "빈 로그인 폼 제출 오류 수정" (코드 관점)
- ✅ "로그인 버튼 클릭 시 반응 없는 문제 수정" (사용자 관점)
- ❌ "null 포인터 예외 처리" (기술적 관점)
- ✅ "프로필 페이지 접근 시 앱 종료되는 문제 수정" (사용자 관점)

간단하고 간결하게 작성. 복잡도에 따라 적절한 형식 사용:

### 매우 간단한 변경사항

```
type: 간결한 설명
```

**예시:**
```
docs: README 오타 수정
```

### 간단한 변경사항

```
type: 문제 상황 설명

무슨 문제가 있었고 어떻게 해결했는지 한두 줄로 설명
```

**예시:**
```
fix: 로그인 버튼 클릭 시 반응 없는 문제 수정

빈 입력 필드로 로그인 시도 시 아무 반응이 없던 문제를
클라이언트 측 검증과 에러 메시지 표시로 해결
```

**여러 변경사항/이유가 있을 때는 리스트 형식 사용:**

```
refactor: 백엔드 아키텍트 에이전트 역할 재정의

- API 설계 중심에서 시스템 구조 설계 중심으로 역할 변경
- 도메인 모델링, 계층 아키텍처, 모듈화 전략에 집중하도록 수정
```

### 표준 변경사항

```
type: 문제 상황 설명

발생한 문제 상황 설명
(재현 가능하면 간단한 재현 방법)

해결 방법과 그 근거를 문장으로 설명

fix #N
```

**예시:**
```
fix: 사용자 목록 페이지 로딩 실패 문제 해결

사용자가 1000명 이상일 때 목록 페이지가 계속 로딩 중으로 표시
(재현: 사용자 목록 > 전체 보기 클릭 시)

데이터베이스에 복합 인덱스 추가와 Redis 캐싱으로
30초 이상 걸리던 응답을 2초 이내로 개선

fix #32
```

### 복잡한 변경사항 (드물게 필요)

```
type: 문제 상황 설명

문제:
- 구체적인 문제 상황 설명
- 재현 방법 (있다면 간략히)

해결책:
- 어떤 접근으로 해결했고 왜 그 방법을 선택했는지
- 추가로 적용한 해결 방법과 근거

fix #N
```

**예시:**
```
fix: 서비스 업데이트 시 자동 로그아웃되는 문제 수정

문제:
- 새 버전 배포할 때마다 모든 사용자가 강제 로그아웃됨
- 작업 중인 내용이 저장되지 않아 사용자 불편 호소

해결책:
- 메모리 세션을 Redis로 마이그레이션하여 배포 시에도 세션 유지
- JWT 리프레시 토큰으로 자동 재인증하여 끊김 없는 서비스 제공
```

**중요한 형식 규칙:**

- 첫 줄(제목): `type: 사용자가 경험하는 문제를 명확히 표현`
- description은 소문자로 시작, 마침표 없음, 명령형 사용
- 가능한 한 사용자 관점 > 코드/기술 관점으로 작성
- 아주 간단한 케이스 제외하고 단순히 변경사항 나열 금지 - 문장으로 설명
- 해결 방법 설명 시 근거와 이유 포함
- 설명은 간결하게 - 장황한 설명을 피한다
- 브랜치명이 숫자로 끝나면 (예: develop/32, develop/shlee/45) 끝에 "fix #N"을 추가한다
- **여러 변경사항/이유가 있을 때는 불릿 포인트(-)를 사용하여 가독성 향상**

## 출력 형식

명령이 제공하는 내용:

1. 스테이징된 변경사항 분석 (없으면 모든 변경사항)
2. **commit_message.md 파일 생성** - 한국어와 영어 버전 모두 포함
3. 파일에서 원하는 버전을 복사하여 사용

## 중요 사항

- 이 명령은 커밋 메시지만 생성하며 - 실제 커밋은 수행하지 않는다
- **commit_message.md 파일에 두 버전 모두 저장** - 원하는 것 선택하여 사용
- **문제 상황에 집중** - 단순 변경사항 나열 금지
- 해결 방법 설명 시 **왜 그렇게 했는지** 근거 포함
- 메시지는 간결하게 - 코드에서 명백한 내용은 과도하게 설명하지 않는다
- 브랜치 이슈 번호(예: develop/32)는 자동으로 "fix #N"을 추가한다
- 생성된 파일에서 메시지 복사 후 `git commit`을 수동으로 실행
- **스펙 준수**: 모든 메시지는 Conventional Commits 형식 필수
- **타입 필수**: 타입 없음 = semantic-release에서 무효 커밋
- **대소문자 구분**: 타입은 소문자 (`BREAKING CHANGE` 제외)

## Claude 실행 지침

1. git 명령어를 실행하여 변경사항 파악 (스테이징된 것 또는 전체)
2. 파일 패턴 분석하여 적절한 커밋 타입 제안
3. scope 필요 여부 판단 (예: `fix(api):`, `feat(ui):`)
4. 커밋 메시지 작성:
   - 제목: `<type>[(scope)]: <사용자 관점 설명>`
   - 본문: 복잡도에 따라 적절한 형식 선택 (매우 간단/간단/표준/복잡)
   - Footer: 브랜치명이 숫자로 끝나면 `fix #N` 자동 추가
5. 한국어와 영어 버전 모두 생성
6. `/workspaces/ai-config-toolkit/commit_message.md`에 저장
7. 제안 타입과 근거 제시

**토큰 최적화**: git diff 분석 시 집중 항목:
- 새로 추가/삭제된 파일 → `feat` 또는 `refactor` 가능성
- src/ 내 수정된 파일 → 버그 수정인지 기능 추가인지 확인
- docs/README 수정 → `docs`
- package.json 수정 → `chore`
